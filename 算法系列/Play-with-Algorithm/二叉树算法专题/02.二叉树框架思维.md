## 题目
1. NO.104 二叉树的最大深度
2. NO.543 二叉树的直径
3. NO.144 二叉树的前序遍历
4. [一套递归模板，解决多个二叉树问题](https://leetcode.cn/problems/maximum-depth-of-binary-tree/solution/yi-tao-mo-ban-jie-jue-duo-ge-by-zhang-xi-yqep/)

## 解题思维
关于二叉树的所有问题都可以按照下面这个解题框架的思维来解决：

1. 是否可以通过遍历一遍二叉树来得到答案？
如果一遍就可以，那么我们需要做的是用一个traverse函数配合外部的全局变量来实现，注意这个traverse函数名可以是任意函数签名不必纠结。
这种遍历一遍二叉树就可以得到答案的思维叫做遍历的思维模式。

2. 是否可以定义一个递归函数，通过子问题(子树)的答案推导出原问题的答案？
如果可以，我们需要做的是写出这个递归函数的定义，并充分利用这个递归函数的返回值，这叫做分解问题的思维模式，就是把一个大的问题变成一个个最小的问题，然后把每一个最小的问题的返回值拼接起来得到最终大问题的答案。

无论是遍历还是分解问题的思维方式，我们都需要思考以下几个问题：
1. 单独抽出一个二叉树节点，它需要做什么事情？
2. 如果需要做事情的话，那么需要在什么时候做？也就是对应前序、中序还是后序的位置做？
3. 只要搞懂一个节点的逻辑，其他节点的逻辑不用操心，因为递归函数会帮你在所有节点上执行相同的操作。


## 二叉树和排序算法（等学习排序算法之后了解）
归并排序：其实就是二叉树的后序遍历
快速排序：其实就是二叉树的前序遍历

## 深入理解二叉树的前中后序遍历

其实单看二叉树的traverse函数，先不管前中后序它就是一个可以遍历二叉树所有节点的一个函数，本质上和遍历数组或者链表没什么区别：

### 迭代/递归遍历数组
```js
function iteratorArray(arr){
	for(let i=0;i<arr.length;i++){
		// 前序访问arr[i]
	}
	for(let i=arr.length-1;i>0;i--){
		// 后序访问arr[i]
	}
}

function reverseArray(arr,index){
	if(arr.length == index) return;
	
	// 前序访问arr[index]
	index++;
	reverseArray(arr,index);
	// 后序访问arr[index]
}
```

### 迭代/递归遍历单链表
```js
function iteratorLinkedList(head){
	for(let node = head;node !== null;node = node.next){
		// 访问node.value
	}
	
	
	let node = head;
	while(node !== null){
		// 访问node.value
		node = node.next;
	}
}

function reverseLinkedList(node){
	if(node == null) return;
	
	// 前序访问node.value
	reverseLinkedList(node.next);
	// 后序访问node.value
}
```

### 递归遍历二叉树
一般来说二叉树的遍历我们指的都是递归遍历，虽然通过while迭代配合栈也可以二叉树的非递归遍历，但是理解起来比较复杂，所以本文中的二叉树遍历就指的是递归方式的遍历。二叉树的遍历模板如下：
```js
function traverse(node){
	if(node == null) return;
	// 前序位置代码
	traverse(node.left);
	// 中序位置代码
	traverse(node.right);
	// 后序位置代码
}
```

我们通过观察数组、单向链表和二叉树的递归遍历函数可以得出一个结论：那就是只要是递归形式的遍历，都可以有前序和后序遍历两种位置，分别在递归函数之前和之后。
前序位置：就是刚进入一个节点的时候，此时指针已经指向节点了，但是还没有做其他事情，是进入的第一刻。
后序位置：就是即将要离开一个节点的时候，此时指针还没有离开节点，但是还没有完全离开，是离开的最后一刻，即将去下一个节点。后序遍历的本质就是利用递归函数不断执行的函数栈帮我们实现了倒序遍历的效果。
所以把代码写在前序位置和后序位置，我们最终得到的结果完全不同。但是二叉树和链表数组不同的地方在于多一个中序遍历。

### 二叉树前中后序遍历的本质
二叉树的前中后序遍历不仅仅意味着可以得到三种不同顺序的节点列表，其本质是在遍历一颗二叉树的过程中，处理每一个节点的三个特殊时间点。
前序位置的代码在刚刚进入一个二叉树节点的时候执行；
后序位置的代码在即将离开一个二叉树节点的时候执行；
中序位置的代码在一个二叉树节点左子树已经遍历完成，即将开始遍历右子树的时候执行。

每一个二叉树节点都有唯一的属于自己的前中后序位置，所以我们认为前中后序遍历是遍历二叉树过程中处理每一个节点的三个特殊时间点。

多叉树没有中序位置，这是因为二叉树的每个节点只会进行一次唯一的左子树切换右子树，而多叉树节点可能会有多个子节点多个子树，所以没有左子树的概念，也就没有唯一一个左子树向右子树切换的位置。

### 二叉树算法问题的本质
二叉树所有问题，都是让你在前中后序位置(注意是位置，也就是时间点)通过思考注入巧妙的代码逻辑，我们只需要单独思考2个问题：
1. 单独抽出一个节点，它需要做什么事情可以完成要求？
2. 做这个事情是在那个合适的时机做？前中后序位置？
只要搞明白一个单独节点的逻辑，其他的就不用管了，都交给二叉树因为我们写的递归函数会帮我们对所有节点都执行相同的操作




