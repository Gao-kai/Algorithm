1. 费曼学习法，输入不是关键，关键是可以输出给别人
2. 遇到稍微难一点的不要逃避 要学会它 但是也不要钻牛角尖
3. 刚开始学习以慢为主，打基础的时候一定要慢慢来
4. 你应该学习的是一个个的知识点 而不是一个大的方向 把某个方向的所有知识点写在一张纸上 学会的划去 不会的新增进来 学会一个知识点的标志是你可以用最最最通俗的说法给别人

## 认识递归(Recursion)

### 1.递归定义
递归就是函数通过直接或者间接的方式调用自己，是一种常见的编程技巧。
比如下面这个简单的例子：给定一个整数n，求1+2+3+...+n的和。
```js
function sum(n){
	if(n==1) return 1;
	// sum不停的调用自己 直到参数n=1的时候停止递归调用
	return n + sum(n-1);
}
```

### 2.普通函数调用过程
不管是何种类型的函数，在调用的时候都会做下面两件事：
1. 开辟一个新的栈帧空间
2. 栈空间中存放和维护当前这个正在调用的函数参数和局部变量

在函数执行完成之后，就会将当前执行结束的函数栈从函数调用栈的栈顶弹出，栈空间内部的变量就得以回收和释放。注意只有函数return语句执行完成才会回收栈空间，如果上一个函数没有执行完成也就是没有return结果，那么这个函数的调用栈就不能回收。


以下面这个普通函数的嵌套调用为例：
```js
function A(num){
	let a = num + 100;
	B(a);
}
function B(v){
	let b = v + 200;
	C(b);
}
function C(v){
	console.log(v);
}
A(10);
```
执行A函数之后形成的函数调用栈如下：
```bash
内存地址0X003 [C,v = 310] 栈顶
内存地址0X002 [B,v = 110,b = 310]
内存地址0X001 [A,num = 10,a = 110] 栈底
```
1. C函数执行结束，打印v的值之后从栈顶弹出；
2. C函数执行结束意味着B函数执行也结束，B函数的栈帧也从栈顶弹出；
3. B函数执行结束意味着A函数执行也结束，A函数的栈帧也弹出
4. 函数执行完成，栈空间被全部回收。

### 3.递归函数的调用过程
递归函数不同于普通函数的调用过程，最明显的一个区别是如果递归函数没有一个终止条件的话，将会一直消耗栈空间直到栈内存溢出(StackOverflow),因此凡是递归函数必须得有一个结束递归的终止条件，这是递归函数实现的前提。

下面以sum递归函数调用的过程为例，分析下递归函数的调用过程：
```js
function sum(n){
	if(n==1) return 1;
	// sum不停的调用自己 直到参数n=1的时候停止递归调用
	return n + sum(n-1);
}
sum(4);
```
当sum(4)函数开始执行之后，函数调用栈中的情况如下：
```bash
内存地址0X004 [sum(1) n=1] retrun 1;
内存地址0X003 [sum(2) n=2] retrun 2+sum(1);
内存地址0X002 [sum(3) n=3] retrun 3+sum(2);
内存地址0X001 [sum(4) n=4] retrun 4+sum(3);
```
1. sum(4)执行，开辟栈内存空间存放参数n=4，返回4+sum(3);
2. sum(3)执行，开辟栈内存空间存放参数n=3，返回3+sum(2);
3. sum(2)执行，开辟栈内存空间存放参数n=2，返回2+sum(1);
4. sum(1)执行，开辟栈内存空间存放参数n=1，满足终止条件返回1，函数执行结束，从栈顶弹出。
5. sum(2)拿到sum(1)执行的结果，返回3，函数执行结束，从栈顶弹出。
6. sum(3)拿到sum(2)执行的结果，返回6，函数执行结束，从栈顶弹出。
7. sum(4)拿到sum(3)执行的结果，返回10，函数执行结束，从栈顶弹出。
8. 函数栈空间被回收，函数执行结束。


## 递归函数复杂度分析
还是以sum函数举例，分别分析下该递归函数的时间复杂度和空间复杂度：
```js
function sum(n){
	if(n==1) return 1;
	// sum不停的调用自己 直到参数n=1的时候停止递归调用
	return n + sum(n-1);
}
sum(4);
```

1. 时间复杂度
通过对sum函数的执行过程分析得出，当传入的参数n=4的时候，函数计算出结果总共进行了4次运算，所以当数据规模为n的时候，对应的时间复杂度应该是T(n) = T(n-1) + O(1),所以总的时间复杂度应该是O(n)

2. 空间复杂度
所有递归函数的空间复杂度都有一个计算公式：
```bash
空间复杂度 = 递归嵌套的层数 * 每一次执行函数所用到的额外辅助空间(如局部变量、参数等)
```
对于sum函数而言，其空间复杂度就是：层数(n) * 辅助空间(1) = O(n)

> 如果使用迭代实现
时间复杂度O(n)不变，空间复杂度可减低到O(1),因为只有一个函数调用栈，只维护一个res变量即可
```js

function sum(n){
	let res = 0;
	for(let i=1;i<=n;i++){
		res+=i;
	}
	return res;
}
sum(4)
```

> 如果使用数学公式实现
从1+2+3+..+n用数学公式推导为：
```js
// 正序相加
S1 = 1 + 2 + 3 +...+ n-1 + n;
// 倒序相加
S2 = n + n-1 + n-2 + ... + 2 + 1

// 相加
S1+S2 = (n+1) + (n+1) + ... + (n+1);
S1 = S2;
2S1 = n(n+1)
S1 = n(n+1)/2

function sum(n){
	return n(n+1)/2;
}
```

通过对同一问题递归实现和迭代实现复杂度的对比可以得出结论：
1. 使用递归不是为了求出最优解，多数是为了简化解决问题的思路，大大简化代码
2. 递归多数情况下得出的解不是最优解法，甚至有O(2^n)这种复杂度的出现
3. 递归也有一些情况下得出的解反而是最优解

## 递归函数基本思想
所有可以用递归解决问题的，都可以概括为以下两个大思路：

### 将大问题拆解成小问题
1. 把一个规模很大的问题变成规模小一点点的同类型问题，注意是同类型问题。
比如一上来喊你求1+2+3+..+1000的和，这是一个规模很大的问题，很难一次性得出问题的解，那么我们就可以将其分解成小一点点的同类型问题，比如分解为先求1+2+3+...+999的和S1，再用S1的和加上1000得出最终的解。

2. 把规模较小的问题持续不断的变成规模更小的同类型问题
将1+2+3+...+999的和继续分解为：先求1+2+3+...+998的和再加上999;
将1+2+3+...+998的和继续分解为：先求1+2+3+...+997的和再加上998;
...依次类推
3. 规模小到一定程度就可以直接得出解
将1+2+3的和继续分解为：先求1+2的和再加上3;
将1+2的和继续分解为：先求1的和再加上2;

当求和的数字为1的时候自不然就可以直接得出这个最小问题的解sum(1) = 1;

### 小问题的解拼接得到大问题的解 
1. 由最小问题的解得出稍微大一点点问题的解
比如由sum(1) = 1就可以得出sum(2) = 2 + sum(1) = 3的解

2. 由大一点点问题的解不断得出规模较大的解
sum(3) = 3 + sum(2) = 6;
sum(4) = 4 + sum(3) = 10;
sum(5) = 5 + sum(4) = 15;
...依次类推

3. 最后得出原来大问题的解
sum(999) = 999 + sum(998);
sum(1000) = 1000 + sum(999);

### 递归思想应用
凡是可以利用上诉这种思想解决问题的，都可以尝试使用递归去实现，比如：
1. 链表这种数据结构天然就具备递归的特点，因为链表中又包含链表，且属性完全统一
2. 二叉树这种数据结构天然具备递归的特点，因为二叉树的左节点和右节点又是一颗二叉树

## 递归函数实现套路
还是以sum求和为例，以下面三个步骤来实现这个sum函数：

1. 明确函数的功能是做什么的？输入参数是什么？返回的结果是什么？
先不要去思考里面代码怎么写，首先搞清楚这个函数的干嘛用的，能完成什么功能？
sum函数的功能是用户输入参数n，n为正整数，sum函数可以返回从1连续加到n的和。

2. 找原问题与小一点点的子问题的关系
往往就是寻找f(n)和f(n-1)的关系
寻找sum(n)和sum(n-1)的关系，分析只知道：sum(n)的结果就是sum(n-1)的结果加上n本身。

3. 找递归终止结束条件
+ 递归的过程中，子问题的规模在不断减小，当小到一定程度时可以直接得出它的解
+ 相当于是思考：问题规模小到什么程度可以直接得出解？
其实就是找最小问题的解，当n=1的时候，sum(1)的解就是1


## 递归案例一：斐波那契额数列
F(1)=1，F(2)=1, F(n)=F(n-1)+F(n-2)（n≥3)
编写一个函数求第n项的斐波那契数
### 1. 递归实现
```js
function fib(n){
	if(n<=2) return 1;
	return fib(n-1) + fib(n-2);
}
```
时间复杂度：O(2^n)，出现了很多重复计算，是一种自顶向下的调用过程。
空间复杂度：O(n)

### 2. 缓存数组实现
递归实现的过程中会存在很多重复的无用计算，如果我们可以将已经计算过的结果存在一个数组里，将这个数组的第1项和第2项设置为最小值1，然后不断为数组赋值的过程就是求解的过程。这里的缓存数组会减少很多重复的计算。
```js
function fib(n){
	if(n<=2) return 1;
	let memoArr = [];
	memoArr[1] = memoArr[2] = 1;
	return _fib(memoArr,n);
}

function _fib(memoArr,n){
	if(!memoArr[n]){
		memoArr[n] = _fib(memoArr,n-1) + _fib(memoArr,n-2);
	}
	return memoArr[n];
}
```
时间复杂度：O(n)
空间复杂度：O(n)

### 3. 迭代 + 缓存数组实现
将递归转化为迭代，是一个自底向上的计算过程；递归是自顶向下的调用过程。
```js
function fib(n){
	if(n<=2) return 1;
	let memoArr = [];
	memoArr[1] = memoArr[2] = 1;
	
	for(let i=3;i<=n;i++){
		memoArr[i] = memoArr[i-1] + memoArr[i-2]; 
	}
	
	return memoArr[n];
}
```
时间复杂度：O(n)
空间复杂度：O(n)

### 4. 滚动数组实现
由于每次运算只需要用到数组中的两个元素来计算，所以可以在上一步的基础上再做优化：
+ 任何整数%2的值只可能是1或者0，这个0和1恰好可以成为数组唯二的两个索引
+ 每次都取arr[0] + arr[1]的值相加，我们要做的就是随着i的增大，不断的去更新arr中的值

时间复杂度：O(n) 
空间复杂度：O(1) 不管N多大 最终结果都是arr的0和1记录 只需要开辟两个内存单元【0,1】
```js
function fib(n){
	if(n<=2) return 1;
	let arr = [];
	arr[0] = arr[1] = 1;
	
	for(let i=3;i<=n;i++){
		arr[i % 2] = arr[(i-1) % 2] + arr[(i-2) % 2]; 
	}
	return arr[n % 2]
}

```

### 5. 取模运算转化为位运算
将一个数n%2，其本质就是求这个数n转化为二进制的最后一位
3%2 = 1; 011 & 001 = 001
4%2 = 0; 100 & 001 = 000
5%2 = 1; 101 & 001 = 001
所以凡是%2的地方都变换为：x % 2 = x & 1; 
按位与 对应的二进制数都是1才是1，否则都是0
1转化为二进制最后一位肯定为1 00000001 
1和任何数 & 运算最后的结果取决于另外一个操作数的二进制最后一位是0还是1
任何数和2的取%运算得到的结果都是这个数的二进制最后一位是1还是0
```js
function fib(n){
	if(n<=2) return 1;
	let arr = new Array(2);
	arr[0] = arr[1] = 1;
	for(let i=3;i<=n;i++){
		arr[i & 1] = arr[(i-1) & 1] + arr[(i-2) & 1]
	}
	return arr[n & 1];
}
```

### 6. 交换变量法
时间复杂度：O(n)，空间复杂度：O(1)
```js
function fib(n){
	if(n<=2) return 1;
	let first = 1;
	let second = 1;
	
	for(let i=3;i<=n;i++){
		second = first + second;
		first = second - first;
	}
	
	return second;
}
```


## 递归案例二：上楼梯(跳台阶)
楼梯有n个台阶，上楼可以一步上1阶，也可以一步上2阶，那么走完n个台阶有多少种不同的走法？

1. 确定函数作用
clib(n)函数输入参数n，表示当前的所有台阶，返回的是走完n个台阶的走法。

2. 观察子问题和总问题的关系
情况1：当第一步走1步的时候，剩余n-1个台阶，总计需要clib(n-1)个走法
情况2：当第一步走2步的时候，剩余n-2个台阶，总计需要clib(n-2)个走法

所以得出结论：clib(n) = clib(n-1) + clib(n-2)

3. 终止条件
当n=1的时候，clib(1) = 1
当n=2的时候, clib(2) = 2

```js
function clib(n){
	if(n<=2) return n;
	return clib(n-1) + clib(n-2);
}
```
由于解题思路和斐波那契额类似，所以优化的思路也是一样的，不再赘述。


## 递归案例三：汉诺塔
编程实现把 A 的 n 个盘子移动到 C (盘子编号是[1,n])
+ 每次只能移动1个盘子
+ 大盘子只能放在小盘子下面

终止条件：
当n=1的时候，直接将盘子从A move到C
当n>1的时候，假设有n个盘子，需要经过3个步骤：
1. 先将n-1个盘子从A移动到空闲的B柱上
2. 再将第n个盘子从A移动到目标C柱上
3. 最后将n-1个盘子从B移动到C上

数据规模在变化逐渐减小
中间的柱子不是固定的,hanno方法的p1参数始终代表起始盘子位置，P2代表空闲柱子，P3代表目标柱子
```js
/**
 * 将n个盘子从P1移动到P3
 * @param {Object} n  盘子个数
 * @param {Object} P1 起始柱子
 * @param {Object} P2 中间的柱子
 * @param {Object} P3 目标柱子
 * 
 * 1.将n-1个盘子从P1移动到P2
 * 2.将第n个盘子从P1移动到P3
 * 3.将n-1个盘子从P2移动到P2
 * 终止条件：当n=1的时候，只需要一步 当n=2的时候，只需要两步
 */

function hanno(n,P1,P2,P3){
	if(n==1){
		remove(n,P1,P3);
		return;
	}
	hanno(n-1,P1,P3,P2);
	remove(n,P1,P3);
	hanno(n-1,P2,P1,P3);
}

function remove(num,from,to){
	console.log(`将第${num}个盘子从${from}移动到${to}`);
}
```

> 复杂度计算
```bash
T(n)  = 2^2 * T(n-2) + 2 * O(1) + O(1)
T(n)  = 2^3 * T(n-3) + 2^2 * O(1) + 2^1 * O(1) + 2^0 * O(1)
T(n)  = 2^n-1 * T(1) + 2^2 * O(1) + 2^1 * O(1) + 2^0 * O(1)

T(n)  = 2^n-1 * O(1) + ... + 2^2 * O(1) + 2^1 * O(1) + 2^0 * O(1)
2T(n)  = 2^n * O(1) + ... + 2^2 * O(1) + 2^1 * O(1) + 2^0 * O(1)

2T(n) - T(n) =  2^n - 1
T(n) = 2^n - 1 

时间复杂度是O(2^n)
空间复杂度是O(n)
```

> 是否可以优化？
此递归函数无法优化，一个递归函数是否可以被优化，关键在于在递归的过程中是否进行了大量重复的运算，如果有就需要使用数组、变量等方法缓存结果，避免进行重复计算，如果没有那就不必优化，因为递归本来就是一个十分消耗时间的操作。

## 递归转非递归函数

### 1. 递归的缺点
递归调用的过程，会将每一次调用的参数和局部变量都保存在对应的函数调用栈帧中Stack Frame中。
递归的缺点在于嵌套的太深，导致栈太深溢出，另外一个缺点是会导致大量的重复计算，比如fib函数
 
解决方案就是：将递归变为非递归 不用担心 递归是一定可以转化为非递归的

### 2. 万能公式
由于递归本质就是不停的创建函数栈空间，直到到达函数的最小边界，然后依次从栈内存中弹出。

我们只需要手动模拟一个栈空间，依次把函数调用的栈压入栈中，然后在合适的时间再依次弹出，虽然时间复杂度没有变化，但是空间复杂度降到了O(1)。
```js
function log(n){
	if(n<1) return;
	log(n-1);
	let v = n+10;
	console.log(v);
}
log(5); 

// log5 n=5 v 15
// log4 n=4 v 14
// log3 n=3 v 13
// log2 n=2 v = 2 + 10 = 12
// log1 n=1 v = 1+10 = 11 
// log0 n=0 return

```

```js
// 模拟的函数栈实例中保存参数和局部变量
function FunCallStack(n,v){
	this.n = n;
	this.v = v;
}

function log(n){
	let stack = [];
	while(n>0){
		let v = n + 10;
		// 依次压入栈中 模拟函数调用栈
		stack.push(new FunCallStack(n,v));
		n--;
	}
	
	while(stack.length){
		// 依次弹出
		let curr = stack.pop();
		console.log(curr.v);
	}
}
```

## 尾调用和尾递归

### 1. 尾调用Tail Call
尾调用的意思一个函数的最后一个动作是调用函数，但是注意下面这种情况不是尾调用：
```js
function tail(n){
	if(n==1) return 1;
	return n * tail(n-1);
}
```
该函数的最后一个动作是n乘以tail(n-1)的值，是乘法而不是尾调用。

### 2. 尾递归调用 Tail Recursion
尾递归调用的意思是一个函数的最后一个动作是调用自身，是尾调用的一种特殊情况

### 3. 尾调用优化 Tail Call Optimization
尾调用优化的原理就是递归函数在重复执行的时候会生成很多栈帧，而每一个栈帧中的参数和局部变量都是相等的，为了减少这种重复的消耗，有一部分语言的编译器会对栈内存空间进行重复的利用，以达到节省栈内存的目的，具体的实现方式就是动态增加栈内存空间的大小。

还是以sum()递归函数来举例：
1. 假设函数sum(5)第一次执行申请了一块栈空间0x001,存储的变量v = 10和参数n = 5

2. sum(4)在执行的时候由于sum(5)函数的最后一步是调用了sum(4)，那么代表sum(5)函数执行栈中的变量和参数已经不需要了，所以这部分空间可以被拿来重复使用，因此之前申请的0X001栈空间继续保持sum(4)执行时的变量v和参数n。

### 4.为什么尾调用可以优化？非尾调用不可以优化呢？
```js
function test1(){
	let a = 10;
	let b = a+10;
	test2();
	let c = a+b;
	console.log(c);
}

function test2(){
	let d = 100;
	let e = 200;
}

```

test2不是尾调用，如果我们对test2执行优化的话，就：
1. test1执行 分配栈空间 里面有a和b局部变量的值
2. test2执行 此时由于要优化 所以不重新分配栈空间 复用test1的栈空间 此时将原来a和b变量存放的值修改为d和e变量的值100 和 200
3. test2执行完成 栈空间暂时不会回收 因为编译器知道这个空间是复用的
4. test1继续执行 打印c 原本c =a+b等于30 由于优化的时候复用了栈空间 所以c = 100 +200 = 300 导致计算结果错误
所以不是尾调用不能随便优化 因为你不知道函数执行后面是否还用到了前面的其他局部变量

尾调用之所以可以优化是因为尾部的函数是最后一句，它知道函数执行之后不会再有其他局部变量，也不会再用到前面的局部变量，所以可以放心的进行栈空间内存的复用

### 5. 尾递归调用优化的本质
尾递归调用优化在汇编语言指令来看就是将函数调用优化成了同一个函数作用域中的while循环
这就没有函数递归调用形成的栈空间了
```js
function demo(n){
	if(n==0) return;
	// 前序位置
	console.log(n) // 5 4 3 2 1
	demo(n-1); // 尾递归调用
}
空间复杂度 O(n) = 递归深度n * 额外辅助空间1 = n



// 等于前序递归
function demo(n){
	while(n>0){
		console.log(n) // 5 4 3 2 1
		n--;
	}
}
demo(5);
空间复杂度O（1）


// 等于后续递归
function demo(n){
	while(n<5){
		console.log(n);
		n++;
	}
}
demo(1);
```
也就是尾递归调用优化也可以将同一个算法的空间复杂度从N降到1，因此我们在写递归算法的时候要尽量实现尾递归调用。


### 6. 尾递归优化案例 阶乘
```js
/**
 * @param {Object} n
 * 1. 递归函数是做什么的？
 * 这个jc函数是实现阶乘的，传入参数n，会返回n的阶乘，也就是n! n * n-1 * n-2 * ... * 2 * 1
 * 2.终止条件
 * 当n==1的时候 jc返回1
 * 当n==2的时候 jc放回2
 * 3. 子问题
 * jc(n) 和 jc(n-1)的关系
 * jc(n) = jc(n-1) * n
 * 
 */
function jc(n){
	if(n<=1) return 1;
	return n * jc(n-1)
}
N * n-1 = n^2 时间复杂度：O(n^2)
空间复杂度:n

function jc(n,prevResult){
	if(n<=1) return prevResult;
	return jc(n-1,n*prevResult)
}

栈1：jc(5,1); n=5,prevResult = 5*1
栈2：jc(4,5*1); n=4,prevResult = 4*5*1
栈3：jc(3,4*5*1); n=3,prevResult = 3*4*5*1
栈4：jc(2,3*4*5*1); n=2,prevResult = 2*3*4*5*1
栈5：jc(1,2*3*4*5*1); n=1,结果返回prevResult = 2*3*4*5*1 = 5的阶乘
```
