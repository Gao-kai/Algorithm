## 题目
-	3. Longest Substring Without Repeating Characters	3. 无重复字符的最长子串	🟠
-	438. Find All Anagrams in a String	438. 找到字符串中所有字母异位词	🟠
-	567. Permutation in String	567. 字符串的排列	🟠
-	76. Minimum Window Substring	76. 最小覆盖子串	🔴
-	-	剑指 Offer 48. 最长不含重复字符的子字符串	🟠
-	-	剑指 Offer II 014. 字符串中的变位词	🟠
-	-	剑指 Offer II 015. 字符串中的所有变位词	🟠
-	-	剑指 Offer II 016. 不含重复字符的最长子字符串	🟠
-	-	剑指 Offer II 017. 含有所有字符的最短字符串	🔴

不固定的窗口
维护定长的窗口

## 口诀
链表子串数组题，用双指针
双指针有三兄弟，用好了作用大的很：
+ 快慢指针
链表操作（比如去除链表中重复元素）
归并排序找中点（还不知道什么是归并排序）
链表成环搞判断（慢的+1 快的+2 有环一定会碰到）
数组原地去重

+ 左右指针
相向而行的左右指针，总有一天会相遇
适合二分搜索
适合数组反转、字符串反转

+ 滑动窗口
主要解决的是找子串的问题
先扩大到窗口足够大 找到一个不是那么好的答案
然后缩小窗口 找最优答案

LeetCode 上有起码 10 道运用滑动窗口算法的题目，难度都是中等和困难

## 框架
时间复杂度是 O(N)，比字符串暴力算法要高效得多。

```js
// 起始的指针都在最左边
let left = right = 0;

// 中止循环条件是right<length
while(right<length){
    // 先取出r元素 再前进一步 避免取不到第一个元素
    let c = arr[right];
    // c是要放入窗口的元素
    window.add(c);
    // 所以right总是跑的快一步 增大窗口
    right++;
    // 对窗口中数据做更新

    // 处理之后判断是否满足最基本条件了
    while(window need sharink){
        let d =arr[left];
        window.add(r);
        // 缩小窗口
        left++;
        // 对窗口数据做更新，完全对称

    }
}
等while训话结束，窗口全部滑动完了
也就拿到正确的结果了

```
1. 窗口window用什么来做比较好？
2. 如何向窗口新增元素和移除元素？
3. 什么时候扩大？
4. 什么时候缩小？
5. 在那个阶段更新全局变量结果

为什么有嵌套的while循环 不是N2的复杂度
而是N的复杂度 N是字符串的长度
因为任何一个字符都只会进入窗口一次并移除窗口一次
不会多次进入或者多次移除

js的map就是字典
 哈希表也被称为散列表，Hash表是一种特殊的数据结构
 JavaScript中的对象具有天然的哈希特性。

window就用对象或者map来装载
判断一个key是否存在于window中
window[key] 这样判断就无法判断值为0的错误
map.get(key) 有就是0 没有就是undefiend
也是一样的 
所以应该是window[key] === undefiend 不存在这才是对的
字符串不需要考虑0的情况
如果有数字就要考虑转化为字符串或者判断是否===undefiend

substrAPI 和slice API的使用

slice(start,end) 
切割总数是end-start个
从start开始包含start元素
切割到end位置结束 不包含end位置

substr(start,len)
切割总数是len个
从start开始 切割len个元素
包含start元素在内

优化点：
1. validCount变量
2. 采用起止位置截取 还是start和len长度截取
3. 没减之前相等，减了就不相等了和
先减少，减了如果比需要的少 那就不行

4. 返回的时候 呀考虑到一个都没有的情况

找到问题了 那就是谁先移除 后移除的问题


<!-- 567. 字符串的排列 -->
1. 窗口小于t的长度的时候一直扩大，只要扩大到等于t之后以后每次就只维护这个定长的窗口即可

2. 定长的窗口 没必要用while 只需要用if 因为每次都只有一次校验的机会，如果当前定长的窗口中不满足，那么马上就把最左边的一位移除了然后去读取新的一位，不会再给你第二次判断的机会

维护定长的窗口 其实里面的判断用if也可以 不一定非要用while
因为第二个while移除一次就退出了 left++依次
right-left的值就变小了

validCount = 1

"AAAA"
windowMap = {
    A:4; // 3
}
3<2 volid-- = 0 其实人家valid是满足的 减去一个还有3个还是满足
我只想了相等的情况 这种情况下确实可以 
但是只要大于等于1 3-1=2 我2还是符合条件的呀 为什么要把我的valid减去
"AABC"
needMap = {
    A:2

+ 最关键的一点没说
什么情况下才可以缩小窗口啊？那就是窗口大小刚好大于等于目标字母串的长度的时候，此时就已经有可能找到答案了

什么情况下可以返回结果？
当当前窗口的宽度刚好等于目标字符串的长度
当前窗口中字母及其个数刚好匹配上目标字符串中每个字符的个数
这时候就可以返回结果了

+ 还有一个就是 内层判断可以是== 从来不会出现大于的情况
窗口增大的时候 是先增大窗口内的元素计数，然后再去更新valid
窗口减小的时候 是先对比更新valid 然后再去减少(很有必要 处理5>3的那种问题)