## 题目

304. 二维区域和检索 - 矩阵不可变
305. 旋转图像 🟠
306. 螺旋矩阵 🟠
307. 螺旋矩阵 II 🟠
     剑指 Offer 29. 顺时针打印矩阵
     剑指 Offer II 013. 二维子矩阵的和
308. 完美矩形

## 使用 JS 初始化一个 m 行 n 列的二维矩阵 值全部为 0

```js
let row = m;
let col = n;
let metric = new Array(row).fill(0).map(()=>new Array(col).fill(0));

0: (5) [0, 0, 0, 0, 0]
1: (5) [0, 0, 0, 0, 0]
2: (5) [0, 0, 0, 0, 0]
3: (5) [0, 0, 0, 0, 0]
4: (5) [0, 0, 0, 0, 0]
```

    时刻要有二维矩阵就是数组的显示这一思维
    第一轮遍历遍历的是第几行i
    第二轮遍历遍历的是第几列j
    通过(i,j)就可以定位某个元素在二维矩阵的位置
    并且现实中的第1行在数组中是第0行

## for 循环二维数组的常见需求

遍历一个二维数组，要求每一行遍历的列数依次-1，比如一个三列三行的二维数组，随着遍历行数的增大列数反而减少的意思。比如：

1. 输出第一行的前三列 012
2. 输出第二行的前两列 01
3. 输出第三行的前一列 0

这个需求说明我们需要控制里面遍历列表的 j 的初始值不变，需要变的是每一轮遍历完成之后的循环中止条件。
也就是原来是小于 len(等于 len-0)才终止，现在每遍历一层之后下一层就需要 len-1 就终止，再下一层就是 len-2 就终止，依次类推。
代码如下：

```js
for (let i = 0; i < len; i++) {
  for (let j = 0; j < len - i; j++) {
    let temp = matrix[i][j];
    // 在此基础上将第i行和第len - 1 - i列进行互换
    matrix[i][j] = matrix[len - 1 - j][len - 1 - i];
    matrix[len - 1 - j][len - 1 - i] = temp;
  }
}
```

还有另外一种随着遍历行数的增大列数反而减少的变体是：

1. 输出第一行的后三列 012
2. 输出第二行的后两列 12
3. 输出第三行的后一列 2

这个和前面发过来，我们会发现这里遍历列表的 j 的值的终止条件没有变，变得是初始值从 0 到 1 到 2.
所以我们需要控制 j 的初始值来控制遍历的列数。而当 j 的值保持和 i 的层数一致的时候，刚好符合条件。
代码如下：

```js
for (let i = 0; i < len; i++) {
  // 最关键的在j的初始值是i,保证了第i行整行的元素和第i列元素交换之后，这些元素不会再被处理又还回去
  for (let j = i; j < len; j++) {
    let temp = matrix[i][j];
    // 交换第i行和第j列的元素
    matrix[i][j] = matrix[j][i];
    matrix[j][i] = temp;
  }
}
```

## 螺旋矩阵

1. 给你一个已经定义好的m*n二维数组，要你按照顺时针的方向依次输出每一个元素的值
   定义上下左右的边界
   设置 while 循环退出的条件也就是 res.length<=m * n
   按照上右下左的顺序依次遍历，遍历完成之后收缩边界
   注意遍历列数据的时候用j，行数据的时候用i

2. 给你要放入二维数组中的数值，比如从1-25，要你构造出来一个二维矩阵，但是这个二维矩阵是顺时针螺旋构造出来的
思路和上面一样
重点是按照上右下左的顺序遍历的时候，给一个初始值num=1，然后依次给二维矩阵赋值，赋值完成之后num++
然后收缩边界


## 构造二维矩阵前缀和
1. 根据原矩阵先初始化一个[m+1][n+1]的二维矩阵
2. 索引i=0和j=0开始遍历二维矩阵,给presum赋值的过程就是构造二维矩阵的过程
3. 赋值的规律就是：presum[i][j]的值始终映射到的是原来矩阵中从原点[0,0]一直到[i-1,j-1]坐标点围着的矩形元素之和
4. 那么如何计算presum[i][j]的值呢？
我们先想下一维数组是如何计算的，presum[i] = presum[i-1] + sum[i-1]
那么presum[i][j]的值应该就是四部分构成：
1. presum[i-1][j](从原点到自己上面这个点的元素之和)
2. presum[i][j-1](从原点到自己左边这个点的元素之和)
3. sum[i-1][j-1](原矩阵中自身的值)
4. presum[i-1][j-1](计算过程中重复的元素区域之和)

前三部分相加然后减去计算中重复计算的第4部分，最后得到的就是从原点[0,0]一直到[i-1,j-1]坐标点围着的矩形元素之和

5. 前缀和构造出来之后，现在给我们两个点的坐标分别为[r1,c1]和[r2,c2]，我们该如何快速计算任意两点间的元素之和呢？
首先[r1,c1]到[r2,c2]间区域的和可以转化为：
1. 坐标原点到[r2,c2]间区域的和S1
2. 坐标原点到[r1-1,c2]间区域的和S2
3. 坐标原点到[r2,c1-1]间区域的和S3
4. 坐标原点到[r1-1,c1-1]间区域的和S4

应该是S1 - S2 - S3 + S4 = presum[r2+1,c2+1] - presum[r1,c2+1] - presum[r2+1,c1] +  presum[r1,c1]
