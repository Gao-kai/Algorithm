二叉搜索树的复杂度分析
课后老师遗留的一些思路

## 思考
如果现在需要我们设计一种数据结构，满足以下三个需求：
1. 可以添加元素
2. 可以获取最大值
3. 可以删除最大值

满足以上需求的数据结构有很多，比如：
1. 数组/双向链表 
数组和双向链表获取最大值的复杂度是O(n),删除最大值的复杂度也是O(n),添加元素默认添加到尾部复杂度是O(1)

2. 有序动态数组/有序双向链表 
有序动态数组/双向链表获取最大值和删除最大值的复杂度都是O(1)，但是添加元素的复杂度是O(n)，因为需要排序之后进行添加

3. 堆
堆获取最大值的复杂度是O(1),删除最大值的复杂度是O(logN),添加元素的复杂度也是O(logN)


## 认识堆(Heap)

### 定义
堆是一种树状的数据结构，和内存管理中的堆空间不是一个东西，一般最常见的堆为二叉堆BinaryHeap

### 特点
1. 堆上任意节点的值总是大于等于或者小于等于其子节点的值，不可能存在某个节点的值大于一些子节点由小于另外一些子节点的情况
2. 堆上任意节点的值都大于其子节点的值，这种堆称之为最大堆或者大顶堆，堆上值最大的元素就是根节点
3. 堆上任意节点的值都小于其子节点的值，这种堆称之为最小堆或者小顶堆，堆上值最小的元素就是根节点

### 用途
堆最大的用途在于从海量的数据中找出前K个最大的数据，也就是经典的Top K问题。

## 二叉堆的特点

### 二叉堆的逻辑结构
关于堆这种数据结构最常见的就是二叉堆，二叉堆的逻辑结构可以看做就是一颗完全二叉树，所以二叉堆也叫作完全二叉堆。

### 二叉堆的物理结构
完全二叉树的一个很重要的特点就是完全二叉树上节点添加和访问的顺序一定是从上而下从左到右的层序遍历机制，这和数组元素添加和访问的机制是一样的，我们向数组中添加元素和遍历数组都是连续的。所以采用数组来实现二叉堆这种数据结构。

### 二叉堆索引i和元素个数n的关系
1. 判断当前节点是否为根节点
如果i为0，那么当前节点是根节点

2. 根据当前节点的索引i求父节点的索引(如果有父节点的话)
如果节点i大于0，那么当前节点的父节点的索引为Math.floor((i-1)/2)

3. 根据当前节点的索引i求左右子节点的索引(如果有左右子节点的话)
```bash
2i+1 <= n-1 当前节点的左子节点的索引为2i+1
2i+2 <= n-1 当前节点的右子节点的索引为2i+2
2i+1 > n-1 ||2i +2 > n-1 当前节点没有左子节点或者没有右子节点
```

## 二叉堆(BinaryHeap)的实现和接口设计
在逻辑上采用完全二叉树来模拟二叉堆，在物理结构上采用线性的数据结构数组来实现二叉堆，二叉堆实现的接口如下：
1. size() 获取元素数量
2. empty() 判断是否为空
3. clear() 清空
4. add() 添加元素
5. get() 获取堆顶元素 
6. remove() 删除堆顶元素
7. replace() 删除堆顶元素的同时插入一个新元素

### 向二叉堆添加新节点（add）

#### 思路一：上滤Sift Up 每次对比并进行位置交换
新添加的元素一定是添加在数组的最末尾，要做的就是将这个新添加的元素一直上滤到合适的位置，保证符合二叉堆的特点。

循环进行以下步骤：
1. 拿到当前节点的值和父节点进行对比
2. 父节点的值大于自己，直接return
3. 父节点的值小于自己，将父节点的值和自己交换
4. 将index的值更新为父节点的索引index值
5. 当前节点没有父节点的时候也就是index=0 终止循环

#### 思路二：上滤Sift Up 只对比改变index值，最终才赋值
1. 拿到当前节点的值和父节点进行对比
2. 父节点的值大于自己，break终止循环，但是不中止函数执行
3. 父节点的值小于自己，将父节点的值存储在原本新节点的index位置处
4. 将index的值更新为父节点的索引index值
5. 当前节点没有父节点的时候也就是index=0 终止循环

### 删除二叉堆的堆顶元素(remove)

删除堆顶元素的步骤：
1. 最后一个节点的值覆盖根节点
2. 删除最后一个节点（障眼法）
3. 将当前根节点进行下滤找到合适的位置

下滤SiftDown操作的步骤：
1. 下滤的节点必须得有子节点，这是进入while循环的前提，只有有子节点才可以取出最大子节点进行交换
2. 只要找到第一个叶子节点，往后所有的节点一定也是叶子节点，假设第一个叶子节点的索引为n，那么只要是大于等于n的索引都是叶子节点
3. 那么如何找到第一个叶子节点的索引n呢？只要找到完全二叉树上非叶子节点的个数，假设个数为5，那么最后一个非叶子节点的索引正好为4,所以第一个叶子节点的索引刚好为5，因此第一个叶子节点的索引就是非叶子节点的个数。

### 二叉堆中元素个数和叶子节点非叶子节点关系
假设一颗二叉堆上有N个节点

此时其叶子节点的个数为：
N0 = Math.floor((N+1) / 2);

此时其非叶子节点的个数为:
N1 + N2 = Math.floor(N / 2);

推导过程如下：
```js
N = N0  + N1 + N2

// 依据1：叶子节点个数一定是度为2的节点个数+1
N0 = N2 + 1;

// 依据2：度为1的节点只能有0个或者1个
当N1 = 0，N = 2N0 -1; N0 = (N+1)/2; N1 + N2 = (N-1)/2
当N1 = 1，N = 2N0, N0 = N/2; N1 + N2 = N/2

// 得出
N0 = Math.floor((N+1)/2);
N1 + N2 = Math.floor((N-1)/2)
```

## 批量建二叉堆Heapify

### 定义
批量建堆的意思就是给你一个乱序的数组，里面有若干项元素，要求你将这个数组转化为二叉堆。

### 方案1：自上而下的上滤heapifyUp
自上而下的上滤指的是将数组元素从头开始依次取出每一个元素，然后执行一次上滤操作。

这样做的原理是每取出一个元素执行一次上滤，每次上滤过的节点组成的是一个最大堆，直到数组中的所有元素上滤完成，那么就会得到一个最大堆，其实就是一点点的形成一个最大堆。

自上而下的上滤的本质就是依次为每一个数组元素执行一次add操作，也就是将每个元素取出来添加到二叉堆中。

由于数组中的第一个元素在上滤的时候没有父节点，所以应该直接从索引为1的地方开始上滤。
```js
let arr = [100,58,63,99,88,152,36];
for(let i=1;i<arr.length;i++){
	siftUp(i); // 从索引1执行上滤
}
```

### 方案2：自下而上的下滤heapifyDown
自下而上的下滤指的是将数组元素从末尾开始依次取出每一个元素，然后执行一次下滤操作。

由于叶子节点是没有子节点的，所以不符合下滤操作的特点，因此自下而上进行下滤的时候，可以省去这些叶子节点，只对非叶子节点进行下滤，其实就是找到最后一个非叶子节点，根据之前推导出来的公式可以得知，完全二叉堆上最后一个非叶子节点的索引就是第一个叶子节点的索引-1，第一个叶子节点的索引就是所有非叶子节点个数：
```js
第一个叶子节点的索引: Math.floor(size / 2)
最后一个非叶子节点的索引:Math.floor(size / 2) - 1
```

自下而上的下滤的本质是当前执行下滤的节点的左右两侧都已经是最大堆，然后再让下滤索引处的节点执行下滤操作，最终形成一个完整的最大堆。其实就是删除remove逻辑的第二步开始之后的操作。

## 小顶堆
由大顶堆的实现可知，我们只需要改变元素和元素之间的比较规则，就可以实现一个小顶堆。
在添加新节点上滤的时候，我们将条件改成只要父节点值比自己小，就一直向上上滤；直到父节点不存在或者父节点的值比自己大，就退出循环。

在移除堆顶节点下滤的时候，要将条件修改为从非叶子节点开始，找到其子节点的最小子节点，然后只要子节点的值比自己小就一直向下下滤即可。

## 二叉堆应用：解决Top K问题
### 1. 问题
从海量的N个数据中，找出前K个最大的值，这里的K是远远小于N的

### 2. 思路
+ 全量排序 O(NlogN)
将N个数据采用快速排序的方法降序排列，然后取出前K个最大的值即可，每一个元素排序的时间复杂度是logN，总共N个元素全部排列完成的总复杂度是NlogN

+ 二叉堆 O(Nlogk)
1. 先新建一个最小堆
2. 将前K个数据依次add到最小堆中，此时堆中有K个元素，size为K
3. 从K+1个元素开始，拿到每一个元素去和堆顶元素比较
4. 如果比堆顶元素还小，那么这个值必然不可能是最大的前K个值，因为比最小的还要小
5. 如果比堆顶元素大，那么就执行replace操作，先用此元素覆盖堆顶的最小值，然后执行下滤操作。
6. 直到N个元素全部访问完成


### 3. 二叉堆实现
```js
function getTopKvalue(arr,k){
	const binaryHeap1 = new BinaryHeap();
	
	for(let i=0;i<arr.length;i++){
		if(binaryHeap1.size < k){  // 0 1 2 3 4
			binaryHeap1.add(arr[i]); // 1 2 3 4 5
		}else if(binaryHeap1.get() < arr[i]){
			binaryHeap1.replace(arr[i])
		}
	}
	
	return binaryHeap1.elements;
}
```

### 4. 数组实现
```js
function getTopKvalue1(arr,k){
	let temp = [];
	for(let i=0;i<arr.length;i++){
		
		if(temp.length < k){  // 0 1 2 3 4
			temp.push(arr[i]); // 1 2 3 4 5
		}else{
			let min = Math.min.apply(null,temp);
			let index = temp.findIndex(item=>item === min);
			if(min < arr[i]){
				temp[index] = arr[i];
			}
		}
	}
	
	return temp.sort((a,b)=>a-b)
}

console.log(getTopKvalue1(arr1,3));
```

## 二叉堆应用：优先级队列的实现
## 二叉堆应用：堆排序的实现
使用堆排序将一个无序数组转化为有序数组，并且空间复杂度能否下降到O(1)