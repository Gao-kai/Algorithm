## 一、计算机中树的相关术语

### 节点的种类
一棵树可以有0个节点、1个节点或者多个节点。0节点的叫做空树、1个节点的代表只有根节点的树。
1. 根节点：一棵树只有一个根节点
2. 父节点
3. 子节点
4. 兄弟节点：只有相同父节点的子节点才可以称作兄弟节点
5. 叶子节点leaf：度为0的节点，也代表该节点下没有任何子节点
6. 非叶子节点：度不为0的节点，也就是该节点至少有一个子节点

### 子树的种类
子树分为左子树和右子树，子树的父节点是相等的。
每一个节点的左节点也是一个二叉树，我们称之为左子树，这个左节点就是整颗左子树的根节点，同理右节点也是一颗二叉树。
### 度 degree
1. 节点的度：当前节点的子树的个数
2. 树的度：当前这棵树上所有节点中度的最大值，也就是所有节点中节点拥有的最多子树的个数。

### 层数 level
一般来说，树的根节点所在的层是第1层，根节点的子节点所在的层是第2层，一次类推得出节点所在的层数。

### 深度 depth
1. 节点的深度
从根节点出发一直到当前节点的唯一路径上经过的节点总数，包含根节点和当前节点在内。

2. 树的深度
所有树节点中节点深度的最大值

### 高度 height
1. 节点的高度
从当前节点出发到其最远叶子节点的路径上经过的的节点总数，和深度不同的地方在于一个是从根节点出发，一个是从当前节点出发。

2. 树的高度
所有树节点中节点高度的最大值。由于所有树节点中从根节点出发的时候其节点高度和深度是一样的，所以树的高度和树的深度是相等的。

## 二、二叉树

### 二叉树的特点
二叉树满足上面所说的树的所有特点，如果一棵树上所有节点的度最大为2,那么我们就称这棵树为二叉树，也就是说二叉树上的节点可能有0个子树、1个子树或者最多2个子树。

### 二叉树的几个重要性质
#### 1. 求非空二叉树上第N层的最大节点个数
我们知道对于一颗非空二叉树来说，其不同层数的最大节点个数为：
```bash
第1层，只有根节点，最大个数为1，也就是2的0次方
第2层，最大节点个数为2，也就是2的1次方
第3层，最大节点个数为4，也就是2的2次方
第4层，最大节点个数为8，也就是2的3次方
```
根据以上推导可知，非空二叉树上第N层的最大节点个数为：2的N-1次方(N>=1)

#### 2. 求深度为h的二叉树上的最多节点总数
```bash
深度为1，只有根节点，树的最多节点个数为1，也就是2的1次方 - 1
深度为2，树的最多节点个数为1 + 2，也就是2的2次方 - 1
深度为3，树的最多节点个数为1 + 2 + 4 ，也就是2的3次方 - 1
深度为4，树的最多节点个数为1 + 2 + 4 + 8，也就是2的4次方 - 1
```
根据以上推导可知，非空二叉树上深度为h的二叉树最多节点总数为2^h -1
也就是n = 2^h -1，进一步推导出最多节点个数n和高度h的关系：h = log2(n+1)

#### 3. 二叉树上度为0和度为2的节点个数关系
1. 求总节点个数

首先我们做一个假设，一颗二叉树上无非就3种节点，假设度为0的节点个数为N0，度为1的节点个数为N1，度为2的节点个数为N2，因为二叉树所有节点最大度数就是2，由此可以得出二叉树上总节点的个数为：
```bash
N = N0 + N1 + N2;
```

2. 求总边数个数

然后我们转化下思路从二叉树的边数入手，这里有1个规律：
+ 二叉树上的节点度为几，那么这个节点下面就有几个直系子节点，也就会有几条边，所以节点的度数degree和节点的边数是相同的。
也就意味着度为2的节点其边数都为2，度为1的节点其边数都为1，度为0的节点其边数都为0，现在我们已经知道度为012节点的个数分别为N0、N1、N2，那么我们可以得出一个计算二叉树所有边数的公式：
```bash
T = N0 * 0 + N1 * 1 + N2 * 2;
```

3. 找总节点数和总边数的规律得出结论

现在我们知道了总节点数N和总边数T，接下来的任务就是找到两者的关系，得出N0和N2的关系，这里有一个重要的规律是：二叉树上的节点除了根节点之外，所有节点的上面都有1条边，所以得出一个结论：总边数 = 总节点数 - 1。
```bash
T = N -1；
N0 * 0 + N1 * 1 + N2 * 2 = N0 + N1 + N2 - 1;
N1 + 2 * N2 = N0 + N1 + N2 - 1;
N2 = N0 -1 ;
N0 = N2 + 1; // 说明度为0的节点个数一定是度为2的节点个数 + 1

```

### 真二叉树 Proper Binary Tree
如果一颗二叉树上所有节点的度要不是0要不是2，也就是没有度为1的节点，那么我们称之为真二叉树。这个真字就体现在如果某个节点的度为1就会出现单叉的情况，这就看起来不像是一个二叉树，因为二叉树看字面意思都是双叉的。

### 满二叉树 Full Binary Tree
如果一颗二叉树上所有节点的度要不是0要不是2，并且其所有的叶子节点都在最后一层，那么我们称之为满二叉树。下面是满二叉树的几条规律：
1. 看定义就知道，真二叉树属于满二叉树，但是满二叉树不一定是真二叉树。
2. 满二叉树的满就体现在一颗二叉树的树节点只有最后一层的叶子节点度为0，其余所有节点的度都是2,这就可以肯定满二叉树是所有二叉树中节点个数最多并且叶子节点个数最多的存在。
3. 满二叉树第n层的节点数量
满二叉树也是二叉树，所以符合之前推导的公式：2的N-1次方(N>=1)

4. 深度为h的满二叉树中叶子节点数量
其实就是求满二叉树中第h层的节点数量，因为满二叉树的深度h就是对应的层数n，满足上述公式：2的h-1次方(h>=1)

5. 深度为h的满二叉树中节点总数量
其实转化下就是求第1层到第h层每一层节点的数量之和，套用上面的公式就是：
2^0 + 2^1 + ... + 2^h-1 = 2的h次方-1，推导公式如下：
```bash
S = 2^0 + 2^1 + 2^2 + ... + 2^h-1;
2S = 0 + 2^1 + 2^2 + ... + 2^h-1 + 2^h;
2S - S = (0 - 2^0) +  (2^1 - 2^1) + (2^h-1 - 2^h-1) + 2^h;
// 得出结论节点总数就是2的h次方-1
S = 2^h - 1
// 反之得出结论树的深度h为：
2^h = S + 1;
h = log2(S+1)
```

### 完全二叉树 Complete Binary Tree
1. 定义
完全二叉树上的叶子节点只会出现在最后两层，并且最底层的叶子节点只会按照从左到右的顺序进行排列。
其实最简单的方法就是把一颗完全二叉树的节点按照相等高度的满二叉树进行编号，其节点的编号顺序是一一对应的。
2. 规律
+ 规律1：完全二叉树也可以通俗的表示为这棵树上的节点排列顺序一定是：从上到下，从左到右
+ 规律2：满二叉树属于完全二叉树，并且完全二叉树和它所对应的满二叉树上的节点一定是完全对应的;但是反过来完全二叉树不一定属于满二叉树。
+ 规律3：完全二叉树从根节点开始到倒数第二层是一颗满二叉树。
+ 规律4：完全二叉树上度为1的节点只有1个或者0个，并且度为1的节点只有左子树，不可能是右子树，因为这样子就不满足从左到右依次排列的特性了。
+ 规律5：同样节点数量的二叉树，完全二叉树的高度 一定最小，因为它严格的按照从上到下从左到右的顺序排列，从上上一层铺满才开始铺下一层。

3. 数学性质
+ 层数为n的完全二叉树上可拥有的最少节点数量：2的n-1次方
其实也就是层数为n的二叉树上，前n-1层为满二叉树，第n层只有1个节点的情况。由前面二叉树的特性可知：
层数为n的二叉树上的最多节点总数为2的n次方-1；
层数为n-1的二叉树上的最多节点为2的n-1次方-1。
再加上第n层的一个节点，那么最小节点数量就是2的n-1次方-1+1 = 2的n-1次方

+ 层数为n的完全二叉树上的最多节点数量: 2的n次方 -1
最多节点数量其实就是当这颗完全二叉树为满二叉树的情况，此时树上节点最多并且数量为2的n次方 -1

+ 完全二叉树层数n和节点数量S的公式
假设完全二叉树上的节点总数为S，由前面的两个数学性质可知其范围为：
```bash
2^(n-1) <= S < 2^n -1

分别取对数之后推导如下：
n-1 <= log2S < n

n是层数肯定是整数，但是log2S计算的结果就有可能是小数，并且我们通过观察可以看出，一个数要满足大于n-1并且小于n，那么n一定是这个数向下取整然后加1。
假设log2S的值为4.2，那么只有n等于5才满足条件
假设log2S的值为6.0，那么只有n等于7才满足条件
假设log2S的值为8.9，那么只有n等于9才满足条件
```

所以最后得出公式：
```bash
n = Math.floor(log2S) + 1;
```

### 完全二叉树题目
1. 题目
假设一颗完全二叉树有768个节点，求这颗二叉树上的叶子节点和非叶子节点的个数。

2. 分析
由前面所学可知，假设一颗完全二叉树上的节点总数为N，并且度为0的节点个数为N0，度为1的节点个数为N1，度为2的节点个数为N2，所以得出公式1：
N  = N0 + N1 + N2

并且任意一颗二叉树包含完全二叉树在内，其度为0的节点个数N0和度为2的节点个数N2的关系为：
N0 = N2 + 1

综合以上两个条件，得出公式：
N = 2N0 + N1 - 1;

接着由完全二叉树的规律4可知，完全二叉树上度为1的节点个数N1只能是0个或者1个，所以首先得出以下结论：
+ 当N1为0的时候，N = 2N0 - 1; 此时可以确定节点总数N一定是奇数
此时叶子节点N0的个数为(N+1)/2;非叶子节点N1+N2的个数为(N-1)/2

+ 当N1为1的时候，N = 2N0;此时可以确定节点总数N一定是偶数
此时叶子节点N0的个数为N/2;非叶子节点N1+N2的个数为N/2

其实到这里，这道题的答案已经可以解出来了，由于总节点个数为768为偶数，所以叶子节点N0的个数就是768/2 = 384个，非叶子节点个数也是384个。

3. N和N0的数量关系：向下取整
但是一般在编程的时候，我们还需要对N的个数进行奇数或者偶数的判断，而我们通常判断奇数和偶数最多的方法就是取模运算,如果一个数%2的值等于=0，那么这个数是偶数，否则就是奇数。但是我们前面也说过，计算机运算中取模运算相比较与整数加减乘除运算是比较消耗性能的，所以这里我们需要对取模运算做一层变换：
```bash
当节点总数N为奇数的时候,叶子节点数量为：N0 = (N+1) / 2 = (N / 2 + 1 / 2),
当节点总数N为偶数的时候,叶子节点数量为：N0 = N / 2
```
那么有没有一种统一的方法可以将以上两个公式统一依赖呢？假设我们就按照节点数量为奇数的时候公式来计算：N0 = (N+1) / 2。观察发现节点总数为偶数的情况之所以不行是因为多加了一个1/2，所以我们就可以借助于向下取整来实现：
```bash
假设N为奇数，N0 = Math.floor((N+1) / 2),本来(N+1) / 2的值就是整数，所以向下取整其实得到的值没变化
假设N为偶数，N0 = Math.floor((N+1) / 2),这里(N+1) / 2的值是一个小数，将小数向下取整其实就将1/2取掉了，剩余的是N/2符合预期。
```
综上所述，得出最终总节点个数N和叶子节点N0个数的公式为：
```bash
N0 = Math.floor((N+1) / 2)
```

4. N和N0的数量关系：向上取整
进一步转化思路还可以想出，其实都用统一的节点数量为偶数的时候来计算：N0 = N / 2，观察发现节点总数为奇数的情况之所以不行是因为少加了一个1/2，所以我们就可以借助于向上取整来实现：
```bash
假设N为奇数，N0 = Math.floor(N / 2),这里N / 2的值就是小数，所以将小数向上取整其实就多加了一个1/2，符合预期。
假设N为偶数，N0 = Math.floor(N / 2),这里N / 2的值本来就是整数，向上取整其实得到的值没变化
```
综上所述，得出最终总节点个数N和叶子节点N0个数的公式为：
```bash
N0 = Math.ceil(N / 2)
```

N0 = n+1/ 2，N1+N2 = n-1/ 2
N0 = n/2

n为偶数，N0 = n/2，N1+N2 = n/2
n为奇数，N0 = n+1/2，N1+N2 = n-1/2

N0 = Math.floor(n+1/2)
N1+N2 = Math.ceil(n-1/2)