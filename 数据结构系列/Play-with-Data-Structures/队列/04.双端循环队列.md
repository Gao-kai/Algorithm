## 双端循环队列
双端循环队列也是基于数组实现的，它不仅可以从头部插入，也可以从尾部移除。
双端循环队列的大多数操作都是和循环队列一样的，只是有几个地方需要注意：

1. 从头部插入新元素
一般来说队列是不允许从头部插入元素的，双端循环队列从头部插入元素可以理解为要从索引为first的前一个位置插入元素，也就是first-1的位置，当first为0的时候就是-1，然而数组的索引不能是-1，所以这里我们在对索引做转换的时候还需要注意一个事情：那就是当first+index的值为负数的时候，这个索引还需要加上数组的长度，也就是-1其实就是往索引为arr.length-1也就是数组最后一位赋值，其实这一点和数组API slice以及splice方法有点类似。
```js
/* 普通数组和循环数组索引转化方法 */
transFormIndex(index){
	let finalIndex =  (this.first + index) % this.items.length;
	// 如果转换后的索引为负数 那么还需要加上数组长度 才是最终要插入元素的索引
	if(finalIndex < 0){
		finalIndex += this.items.length;
	}
	return finalIndex;
}
```

2. 从尾部移除元素
从尾部移除元素的时候，其实要移除位置的索引就是first+size-1，基于这个逻辑去套上面的公式就好了。


## %运算符的优化思路
在计算机程序中，我们最好避免使用*、/、%以及浮点数运算，因为这些操作的底层都是二进制数的运算，计算效率是相对很低的，因此我们应该将这种运算尽可能的转化成为加法、减法或者比较大小的运算，下面分析下取模运算的优化思路：

1. 如果n >= m && n < 2m，计算结果如下：
```js
10 % 6 = 4 等价于 10 - 6 = 4;
13 % 9 = 4 等价于 13 - 9 = 4;
20 % 20 = 0 等价于 20 - 20 = 0;
20 % 9 = 2 不等于 20 -9 = 11; 这是因为n的值大于了2倍的m
```
由此可以发现上面这种情况其实就等价于n - m的值，但是需要注意必须满足n < 2m。

2. 如果n < m，计算结果如下：
```js
5 % 10 = 5 
9 % 13 = 9 
7 % 8 = 7 
```
由此可以发现上面这种情况其实就等价于n本身的值，当然这里需要满足m>0,因为不能对0取模；并且n>=0,n不考虑为负数的情况。

3. 归纳总结
综上所述，我们可以得出当n>=0,m>0,n<2m的情况下取模运算的一般公式：
```js
if(n>=m){
	let res = n-m;
}else{
	let res = n;
}
```
可以进一步的简化出来n%m的写法为：
```js
n % m = n - (n >= m ? m : 0);
```
这样我们就实现了将取模运算简化为减法运算和三目运算符的综合运算，提高了运算效率。

4. 应用到循环队列中
在循环队列中，我们是使用数组实现的，并且经过之前的分析得出结论：
+ 在循环队列的尾部入队的时候，其最极限的情况也就是假设数组长度为7，当前数组中元素size的个数已经为6，first的指针最大指向的数组索引为6，那么此时first + size的最大值也是小于2倍的length的，并且数组的索引不可能为负数，是符合以上公式的条件n<2m的。所以循环队列计算要插入元素在原数组中真实索引的公式为：
```js
let lastIndex = (first + size) % arr.length; // 加size就是因为插入到末尾，如果数组中元素个数为5，那么插入的索引就是5，也就是第六个元素
```
经过上述的取模运算的优化结果就是：
```js
let index = first + size;
let lastIndex = index - (index >= arr.length ? arr.length : 0)
```





