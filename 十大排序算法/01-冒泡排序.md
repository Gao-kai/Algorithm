1. 基本实现
2. 优化思路
提前终止 用boolean 如果第一轮扫描的时候一次都没有交换 
那么每一对元素都是排序ok的 

第三趟
每一趟扫描之前都假设是已经排序好的
如果需要交换 那么就已经假设是不成立的 往下执行代码
如果假设成立 在这一轮扫描结束之后 就return掉

不一定提前有序
反而第二种要多执行代码，反而效率更加低
ASCorder升序**

1. 第一种优化思路
是假设所有数据都是提前排好序的 这种情况概率很小 还不如不优化

2. 第二种优化思路
假设数组的尾部已经局部有序 那么记录最后一次交换的位置 该位置后面的元素不再排序
这个情况是很常见的 
越到后面越有很大优化的空间

10个数按照规则来说就要扫描9轮
如果我知道最后6个数已经排序好了
那么索引456789的值是已经排序好的
现在只要排序索引0123这4个数就可以了
此时4个数需要3轮扫描

我们需要在下一轮开始扫描前改变最终扫描的轮数
